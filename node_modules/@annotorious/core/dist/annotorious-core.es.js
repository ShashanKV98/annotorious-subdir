var Y = Object.prototype.hasOwnProperty;
function B(e, n) {
  var t, o;
  if (e === n)
    return !0;
  if (e && n && (t = e.constructor) === n.constructor) {
    if (t === Date)
      return e.getTime() === n.getTime();
    if (t === RegExp)
      return e.toString() === n.toString();
    if (t === Array) {
      if ((o = e.length) === n.length)
        for (; o-- && B(e[o], n[o]); )
          ;
      return o === -1;
    }
    if (!t || typeof e == "object") {
      o = 0;
      for (t in e)
        if (Y.call(e, t) && ++o && !Y.call(n, t) || !(t in n) || !B(e[t], n[t]))
          return !1;
      return Object.keys(n).length === o;
    }
  }
  return e !== e && n !== n;
}
function $() {
}
function W(e, n) {
  return e != e ? n == n : e !== n || e && typeof e == "object" || typeof e == "function";
}
const k = [];
function _(e, n = $) {
  let t;
  const o = /* @__PURE__ */ new Set();
  function i(b) {
    if (W(e, b) && (e = b, t)) {
      const w = !k.length;
      for (const u of o)
        u[1](), k.push(u, e);
      if (w) {
        for (let u = 0; u < k.length; u += 2)
          k[u][0](k[u + 1]);
        k.length = 0;
      }
    }
  }
  function h(b) {
    i(b(e));
  }
  function U(b, w = $) {
    const u = [b, w];
    return o.add(u), o.size === 1 && (t = n(i) || $), b(e), () => {
      o.delete(u), o.size === 0 && t && (t(), t = null);
    };
  }
  return { set: i, update: h, subscribe: U };
}
const be = (e) => {
  const { subscribe: n, set: t } = _(null);
  let o = null;
  return n((i) => o = i), e.observe(({ changes: i }) => {
    if (o) {
      i.deleted.some((b) => b.id === o) && t(null);
      const U = i.updated.find(({ oldValue: b }) => b.id === o);
      U && t(U.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: n,
    set: t
  };
};
var q = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(q || {});
const V = { selected: [] }, ve = (e, n = "EDIT") => {
  const { subscribe: t, set: o } = _(V);
  let i = V;
  t((s) => i = s);
  const h = () => o(V), U = () => {
    var s;
    return ((s = i.selected) == null ? void 0 : s.length) === 0;
  }, b = (s) => {
    if (i.selected.length === 0)
      return !1;
    const f = typeof s == "string" ? s : s.id;
    return i.selected.some((y) => y.id === f);
  }, w = (s, f) => {
    const y = e.getAnnotation(s);
    if (y) {
      const A = G(y, n);
      o(A === "EDIT" ? { selected: [{ id: s, editable: !0 }], pointerEvent: f } : A === "SELECT" ? { selected: [{ id: s }], pointerEvent: f } : { selected: [], pointerEvent: f });
    } else
      console.warn("Invalid selection: " + s);
  }, u = (s, f = !0) => {
    const y = Array.isArray(s) ? s : [s], A = y.map((L) => e.getAnnotation(L)).filter((L) => L);
    o({ selected: A.map(({ id: L }) => ({ id: L, editable: f })) }), A.length !== y.length && console.warn("Invalid selection", s);
  }, T = (s) => {
    if (i.selected.length === 0)
      return !1;
    const { selected: f } = i;
    f.filter(({ id: A }) => s.includes(A)).length > 0 && o({ selected: f.filter(({ id: A }) => !s.includes(A)) });
  };
  return e.observe(({ changes: s }) => T(s.deleted.map((f) => f.id))), {
    clear: h,
    clickSelect: w,
    get selected() {
      return i ? [...i.selected] : null;
    },
    get pointerEvent() {
      return i ? i.pointerEvent : null;
    },
    isEmpty: U,
    isSelected: b,
    setSelected: u,
    subscribe: t
  };
}, G = (e, n) => typeof n == "function" ? n(e) || "EDIT" : n || "EDIT";
let z;
const H = new Uint8Array(16);
function F() {
  if (!z && (z = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !z))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return z(H);
}
const R = [];
for (let e = 0; e < 256; ++e)
  R.push((e + 256).toString(16).slice(1));
function J(e, n = 0) {
  return R[e[n + 0]] + R[e[n + 1]] + R[e[n + 2]] + R[e[n + 3]] + "-" + R[e[n + 4]] + R[e[n + 5]] + "-" + R[e[n + 6]] + R[e[n + 7]] + "-" + R[e[n + 8]] + R[e[n + 9]] + "-" + R[e[n + 10]] + R[e[n + 11]] + R[e[n + 12]] + R[e[n + 13]] + R[e[n + 14]] + R[e[n + 15]];
}
const Q = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), j = {
  randomUUID: Q
};
function X(e, n, t) {
  if (j.randomUUID && !n && !e)
    return j.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || F)();
  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, n) {
    t = t || 0;
    for (let i = 0; i < 16; ++i)
      n[t + i] = o[i];
    return n;
  }
  return J(o);
}
const Ce = (e) => {
  const { creator: n, updatedBy: t } = e.target, o = e.bodies.reduce((i, h) => [...i, h.creator, h.updatedBy], []);
  return [
    n,
    t,
    ...o
  ].filter((i) => i);
}, we = (e, n, t, o) => ({
  id: X(),
  annotation: e.id,
  created: t || /* @__PURE__ */ new Date(),
  creator: o,
  ...n
}), Z = (e, n) => {
  const t = new Set(e.bodies.map((o) => o.id));
  return n.bodies.filter((o) => !t.has(o.id));
}, K = (e, n) => {
  const t = new Set(n.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !t.has(o.id));
}, ee = (e, n) => n.bodies.map((t) => {
  const o = e.bodies.find((i) => i.id === t.id);
  return { newBody: t, oldBody: o && !B(o, t) ? o : void 0 };
}).filter(({ oldBody: t }) => t), te = (e, n) => !B(e.target, n.target), M = (e, n) => {
  const t = Z(e, n), o = K(e, n), i = ee(e, n);
  return {
    oldValue: e,
    newValue: n,
    bodiesCreated: t.length > 0 ? t : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: i.length > 0 ? i : void 0,
    targetUpdated: te(e, n) ? { oldTarget: e.target, newTarget: n.target } : void 0
  };
};
var ne = /* @__PURE__ */ ((e) => (e.BODY_ONLY = "BODY_ONLY", e.TARGET_ONLY = "TARGET_ONLY", e))(ne || {}), O = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e))(O || {});
const oe = (e, n) => {
  var h, U;
  const { changes: t, origin: o } = n;
  if (!(!e.options.origin || e.options.origin === o))
    return !1;
  if (e.options.ignore) {
    const { ignore: b } = e.options, w = (T) => (T == null ? void 0 : T.length) > 0;
    if (!(w(t.created) || w(t.deleted))) {
      const T = (h = t.updated) == null ? void 0 : h.some((f) => w(f.bodiesCreated) || w(f.bodiesDeleted) || w(f.bodiesUpdated)), s = (U = t.updated) == null ? void 0 : U.some((f) => f.targetUpdated);
      if (b === "BODY_ONLY" && T && !s || b === "TARGET_ONLY" && s && !T)
        return !1;
    }
  }
  if (e.options.annotations) {
    const b = /* @__PURE__ */ new Set([
      ...t.created.map((u) => u.id),
      ...t.deleted.map((u) => u.id),
      ...t.updated.map(({ oldValue: u }) => u.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((u) => b.has(u));
  } else
    return !0;
}, se = (e, n) => {
  const t = new Set((e.created || []).map((s) => s.id)), o = new Set((e.updated || []).map(({ newValue: s }) => s.id)), i = new Set((n.created || []).map((s) => s.id)), h = new Set((n.deleted || []).map((s) => s.id)), U = new Set((n.updated || []).map(({ oldValue: s }) => s.id)), b = new Set((n.updated || []).filter(({ oldValue: s }) => t.has(s.id) || o.has(s.id)).map(({ oldValue: s }) => s.id)), w = [
    ...(e.created || []).filter((s) => !h.has(s.id)).map((s) => U.has(s.id) ? n.updated.find(({ oldValue: f }) => f.id === s.id).newValue : s),
    ...n.created || []
  ], u = [
    ...(e.deleted || []).filter((s) => !i.has(s.id)),
    ...(n.deleted || []).filter((s) => !t.has(s.id))
  ], T = [
    ...(e.updated || []).filter(({ newValue: s }) => !h.has(s.id)).map((s) => {
      const { oldValue: f, newValue: y } = s;
      if (U.has(y.id)) {
        const A = n.updated.find((L) => L.oldValue.id === y.id).newValue;
        return M(f, A);
      } else
        return s;
    }),
    ...(n.updated || []).filter(({ oldValue: s }) => !b.has(s.id))
  ];
  return { created: w, deleted: u, updated: T };
}, ie = (e) => e.id !== void 0, ye = () => {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), t = [], o = (r, l = {}) => t.push({ onChange: r, options: l }), i = (r) => {
    const l = t.findIndex((a) => a.onChange == r);
    l > -1 && t.splice(l, 1);
  }, h = (r, l) => {
    const a = {
      origin: r,
      changes: {
        created: l.created || [],
        updated: l.updated || [],
        deleted: l.deleted || []
      },
      state: [...e.values()]
    };
    t.forEach((p) => {
      oe(p, a) && p.onChange(a);
    });
  }, U = (r, l = O.LOCAL) => {
    if (e.get(r.id))
      throw Error(`Cannot add annotation ${r.id} - exists already`);
    e.set(r.id, r), r.bodies.forEach((p) => n.set(p.id, r.id)), h(l, { created: [r] });
  }, b = (r, l) => {
    const a = typeof r == "string" ? l : r, p = typeof r == "string" ? r : r.id, v = e.get(p);
    if (v) {
      const D = M(v, a);
      return p === a.id ? e.set(p, a) : (e.delete(p), e.set(a.id, a)), v.bodies.forEach((x) => n.delete(x.id)), a.bodies.forEach((x) => n.set(x.id, a.id)), D;
    } else
      console.warn(`Cannot update annotation ${p} - does not exist`);
  }, w = (r, l = O.LOCAL, a = O.LOCAL) => {
    const p = ie(l) ? a : l, v = b(r, l);
    v && h(p, { updated: [v] });
  }, u = (r, l = O.LOCAL) => {
    const a = r.reduce((p, v) => {
      const D = b(v);
      return D ? [...p, D] : p;
    }, []);
    a.length > 0 && h(l, { updated: a });
  }, T = (r, l = O.LOCAL) => {
    const a = e.get(r.annotation);
    if (a) {
      const p = {
        ...a,
        bodies: [...a.bodies, r]
      };
      e.set(a.id, p), n.set(r.id, p.id), h(l, { updated: [{
        oldValue: a,
        newValue: p,
        bodiesCreated: [r]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${r.annotation}`);
  }, s = () => [...e.values()], f = (r = O.LOCAL) => {
    const l = [...e.values()];
    e.clear(), n.clear(), h(r, { deleted: l });
  }, y = (r, l = !0, a = O.LOCAL) => {
    if (l) {
      const p = [...e.values()];
      e.clear(), n.clear(), r.forEach((v) => {
        e.set(v.id, v), v.bodies.forEach((D) => n.set(D.id, v.id));
      }), h(a, { created: r, deleted: p });
    } else {
      const p = r.reduce((v, D) => {
        const x = e.get(D.id);
        return x ? [...v, x] : v;
      }, []);
      if (p.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${p.map((v) => v.id).join(", ")}`);
      r.forEach((v) => {
        e.set(v.id, v), v.bodies.forEach((D) => n.set(D.id, v.id));
      }), h(a, { created: r });
    }
  }, A = (r) => {
    const l = typeof r == "string" ? r : r.id, a = e.get(l);
    if (a)
      return e.delete(l), a.bodies.forEach((p) => n.delete(p.id)), a;
    console.warn(`Attempt to delete missing annotation: ${l}`);
  }, L = (r, l = O.LOCAL) => {
    const a = A(r);
    a && h(l, { deleted: [a] });
  }, C = (r, l = O.LOCAL) => {
    const a = r.reduce((p, v) => {
      const D = A(v);
      return D ? [...p, D] : p;
    }, []);
    a.length > 0 && h(l, { deleted: a });
  }, c = (r, l = O.LOCAL) => {
    const a = e.get(r.annotation);
    if (a) {
      const p = a.bodies.find((v) => v.id === r.id);
      if (p) {
        n.delete(p.id);
        const v = {
          ...a,
          bodies: a.bodies.filter((x) => x.id !== r.id)
        };
        e.set(a.id, v), h(l, { updated: [{
          oldValue: a,
          newValue: v,
          bodiesDeleted: [p]
        }] });
      } else
        console.warn(`Attempt to delete missing body ${r.id} from annotation ${r.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${r.annotation}`);
  }, m = (r) => {
    const l = e.get(r);
    return l ? { ...l } : void 0;
  }, d = (r) => {
    const l = n.get(r);
    if (l) {
      const p = m(l).bodies.find((v) => v.id === r);
      if (p)
        return p;
      console.error(`Store integrity error: body ${r} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${r}`);
  }, E = (r, l) => {
    if (r.annotation !== l.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const a = e.get(r.annotation);
    if (a) {
      const p = a.bodies.find((D) => D.id === r.id), v = {
        ...a,
        bodies: a.bodies.map((D) => D.id === p.id ? l : D)
      };
      return e.set(a.id, v), p.id !== l.id && (n.delete(p.id), n.set(l.id, v.id)), {
        oldValue: a,
        newValue: v,
        bodiesUpdated: [{ oldBody: p, newBody: l }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${r.annotation}`);
  }, g = (r, l, a = O.LOCAL) => {
    const p = E(r, l);
    h(a, { updated: [p] });
  }, S = (r, l = O.LOCAL) => {
    const a = r.map((p) => E({ id: p.id, annotation: p.annotation }, p));
    h(l, { updated: a });
  }, I = (r) => {
    const l = e.get(r.annotation);
    if (l) {
      const a = {
        ...l,
        target: {
          ...l.target,
          ...r
        }
      };
      return e.set(l.id, a), {
        oldValue: l,
        newValue: a,
        targetUpdated: {
          oldTarget: l.target,
          newTarget: r
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${r.annotation}`);
  };
  return {
    addAnnotation: U,
    addBody: T,
    all: s,
    bulkAddAnnotation: y,
    bulkDeleteAnnotation: C,
    bulkUpdateAnnotation: u,
    bulkUpdateBodies: S,
    bulkUpdateTargets: (r, l = O.LOCAL) => {
      const a = r.map(I).filter((p) => p);
      a.length > 0 && h(l, { updated: a });
    },
    clear: f,
    deleteAnnotation: L,
    deleteBody: c,
    getAnnotation: m,
    getBody: d,
    observe: o,
    unobserve: i,
    updateAnnotation: w,
    updateBody: g,
    updateTarget: (r, l = O.LOCAL) => {
      const a = I(r);
      a && h(l, { updated: [a] });
    }
  };
}, Ue = (e) => ({
  ...e,
  subscribe: (t) => {
    const o = (i) => t(i.state);
    return e.observe(o), t(e.all()), () => e.unobserve(o);
  }
});
let P = () => ({
  emit(e, ...n) {
    let t = this.events[e] || [];
    for (let o = 0, i = t.length; o < i; o++)
      t[o](...n);
  },
  events: {},
  on(e, n) {
    var t;
    return (t = this.events[e]) != null && t.push(n) || (this.events[e] = [n]), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => n !== i);
    };
  }
});
const de = 250, Le = (e) => {
  const n = P(), t = [];
  let o = -1, i = !1, h = 0;
  const U = (d) => {
    if (!i) {
      const { changes: E } = d, g = performance.now();
      if (g - h > de)
        t.splice(o + 1), t.push(E), o = t.length - 1;
      else {
        const S = t.length - 1;
        t[S] = se(t[S], E);
      }
      h = g;
    }
    i = !1;
  };
  e.observe(U, { origin: O.LOCAL });
  const b = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkDeleteAnnotation(d), w = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkAddAnnotation(d, !1), u = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkUpdateAnnotation(d.map(({ oldValue: E }) => E)), T = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkUpdateAnnotation(d.map(({ newValue: E }) => E)), s = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkAddAnnotation(d, !1), f = (d) => (d == null ? void 0 : d.length) > 0 && e.bulkDeleteAnnotation(d);
  return {
    canRedo: () => t.length - 1 > o,
    canUndo: () => o > -1,
    destroy: () => e.unobserve(U),
    on: (d, E) => n.on(d, E),
    redo: () => {
      if (t.length - 1 > o) {
        i = !0;
        const { created: d, updated: E, deleted: g } = t[o + 1];
        w(d), T(E), f(g), n.emit("redo", t[o + 1]), o += 1;
      }
    },
    undo: () => {
      if (o > -1) {
        i = !0;
        const { created: d, updated: E, deleted: g } = t[o];
        b(d), u(E), s(g), n.emit("undo", t[o]), o -= 1;
      }
    }
  };
}, Se = () => {
  const { subscribe: e, set: n } = _([]);
  return {
    subscribe: e,
    set: n
  };
}, Te = (e, n, t, o) => {
  const { store: i, selection: h, hover: U, viewport: b } = e, w = /* @__PURE__ */ new Map();
  let u = [], T, s;
  const f = (c, m) => {
    w.has(c) ? w.get(c).push(m) : w.set(c, [m]);
  }, y = (c, m) => {
    const d = w.get(c);
    d && d.indexOf(m) > 0 && d.splice(d.indexOf(m), 1);
  }, A = (c, m, d) => {
    w.has(c) && setTimeout(() => {
      w.get(c).forEach((E) => {
        if (t) {
          const g = Array.isArray(m) ? m.map((I) => t.serialize(I)) : t.serialize(m), S = d ? d instanceof PointerEvent ? d : t.serialize(d) : void 0;
          E(g, S);
        } else
          E(m, d);
      });
    }, 1);
  }, L = () => {
    const { selected: c } = h, m = c.map(({ id: d }) => i.getAnnotation(d));
    m.forEach((d) => {
      const E = u.find((g) => g.id === d.id);
      (!E || !B(E, d)) && A("updateAnnotation", d, E);
    }), u = u.map((d) => {
      const E = m.find(({ id: g }) => g === d.id);
      return E || d;
    });
  };
  h.subscribe(({ selected: c }) => {
    if (!(u.length === 0 && c.length === 0)) {
      if (u.length === 0 && c.length > 0)
        u = c.map(({ id: m }) => i.getAnnotation(m));
      else if (u.length > 0 && c.length === 0)
        u.forEach((m) => {
          const d = i.getAnnotation(m.id);
          d && !B(d, m) && A("updateAnnotation", d, m);
        }), u = [];
      else {
        const m = new Set(u.map((g) => g.id)), d = new Set(c.map(({ id: g }) => g));
        u.filter((g) => !d.has(g.id)).forEach((g) => {
          const S = i.getAnnotation(g.id);
          S && !B(S, g) && A("updateAnnotation", S, g);
        }), u = [
          // Remove annotations that were deselected
          ...u.filter((g) => d.has(g.id)),
          // Add editable annotations that were selected
          ...c.filter(({ id: g }) => !m.has(g)).map(({ id: g }) => i.getAnnotation(g))
        ];
      }
      A("selectionChanged", u);
    }
  }), U.subscribe((c) => {
    !T && c ? A("mouseEnterAnnotation", i.getAnnotation(c)) : T && !c ? A("mouseLeaveAnnotation", i.getAnnotation(T)) : T && c && (A("mouseLeaveAnnotation", i.getAnnotation(T)), A("mouseEnterAnnotation", i.getAnnotation(c))), T = c;
  }), b == null || b.subscribe((c) => A("viewportIntersect", c.map(i.getAnnotation))), i.observe((c) => {
    o && (s && clearTimeout(s), s = setTimeout(L, 1e3));
    const { created: m, deleted: d } = c.changes;
    m.forEach((g) => A("createAnnotation", g)), d.forEach((g) => A("deleteAnnotation", g)), c.changes.updated.filter((g) => [
      ...g.bodiesCreated || [],
      ...g.bodiesDeleted || [],
      ...g.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: g, newValue: S }) => {
      const I = u.find((N) => N.id === g.id) || g;
      u = u.map((N) => N.id === g.id ? S : N), A("updateAnnotation", S, I);
    });
  }, { origin: O.LOCAL }), i.observe((c) => {
    if (u) {
      const m = new Set(u.map((E) => E.id)), d = c.changes.updated.filter(({ newValue: E }) => m.has(E.id)).map(({ newValue: E }) => E);
      d.length > 0 && (u = u.map((E) => {
        const g = d.find((S) => S.id === E.id);
        return g || E;
      }));
    }
  }, { origin: O.REMOTE });
  const C = (c) => (m) => {
    const { created: d, deleted: E, updated: g } = m;
    d.forEach((S) => A("createAnnotation", S)), E.forEach((S) => A("deleteAnnotation", S)), c ? g.forEach((S) => A("updateAnnotation", S.oldValue, S.newValue)) : g.forEach((S) => A("updateAnnotation", S.newValue, S.oldValue));
  };
  return n.on("undo", C(!0)), n.on("redo", C(!1)), { on: f, off: y, emit: A };
}, Oe = (e) => (n) => n.map((t) => e.serialize(t)), re = (e) => (n) => n.reduce((t, o) => {
  const { parsed: i, error: h } = e.parse(o);
  return h ? {
    parsed: t.parsed,
    failed: [...t.failed, o]
  } : {
    parsed: [...t.parsed, i],
    failed: t.failed
  };
}, { parsed: [], failed: [] }), De = (e, n, t) => {
  const { store: o, selection: i } = e, h = (C) => {
    if (t) {
      const { parsed: c, error: m } = t.parse(C);
      c ? o.addAnnotation(c, O.REMOTE) : console.error(m);
    } else
      o.addAnnotation(C, O.REMOTE);
  }, U = () => i.clear(), b = () => o.clear(), w = (C) => {
    const c = o.getAnnotation(C);
    return t && c ? t.serialize(c) : c;
  }, u = () => t ? o.all().map(t.serialize) : o.all(), T = () => {
    var m;
    const c = (((m = i.selected) == null ? void 0 : m.map((d) => d.id)) || []).map((d) => o.getAnnotation(d));
    return t ? c.map(t.serialize) : c;
  }, s = (C) => fetch(C).then((c) => c.json()).then((c) => (y(c), c)), f = (C) => {
    if (typeof C == "string") {
      const c = o.getAnnotation(C);
      return o.deleteAnnotation(C), t ? t.serialize(c) : c;
    } else {
      const c = t ? t.parse(C).parsed : C;
      return o.deleteAnnotation(c), C;
    }
  }, y = (C) => {
    if (t) {
      const { parsed: c, failed: m } = re(t)(C);
      m.length > 0 && console.warn(`Discarded ${m.length} invalid annotations`, m), o.bulkAddAnnotation(c, !0, O.REMOTE);
    } else
      o.bulkAddAnnotation(C, !0, O.REMOTE);
  }, A = (C) => {
    C ? i.setSelected(C) : i.clear();
  }, L = (C) => {
    if (t) {
      const c = t.parse(C).parsed, m = t.serialize(o.getAnnotation(c.id));
      return o.updateAnnotation(c), m;
    } else {
      const c = o.getAnnotation(C.id);
      return o.updateAnnotation(C), c;
    }
  };
  return {
    addAnnotation: h,
    cancelSelected: U,
    canRedo: n.canRedo,
    canUndo: n.canUndo,
    clearAnnotations: b,
    getAnnotationById: w,
    getAnnotations: u,
    getSelected: T,
    loadAnnotations: s,
    redo: n.redo,
    removeAnnotation: f,
    setAnnotations: y,
    setSelected: A,
    undo: n.undo,
    updateAnnotation: L
  };
};
let ae = (e) => crypto.getRandomValues(new Uint8Array(e)), ce = (e, n, t) => {
  let o = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * o * n / e.length);
  return (h = n) => {
    let U = "";
    for (; ; ) {
      let b = t(i), w = i;
      for (; w--; )
        if (U += e[b[w] & o] || "", U.length === h)
          return U;
    }
  };
}, le = (e, n = 21) => ce(e, n, ae), ue = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((n, t) => (t &= 63, t < 36 ? n += t.toString(36) : t < 62 ? n += (t - 26).toString(36).toUpperCase() : t > 62 ? n += "-" : n += "_", n), "");
const Re = () => ({ isGuest: !0, id: le("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), fe = (e) => {
  const n = JSON.stringify(e);
  let t = 0;
  for (let o = 0, i = n.length; o < i; o++) {
    let h = n.charCodeAt(o);
    t = (t << 5) - t + h, t |= 0;
  }
  return `${t}`;
}, pe = (e) => e ? typeof e == "object" ? { ...e } : e : void 0, xe = (e, n) => (Array.isArray(e) ? e : [e]).map((t) => {
  const { id: o, type: i, purpose: h, value: U, created: b, creator: w, ...u } = t;
  return {
    id: o || `temp-${fe(t)}`,
    annotation: n,
    type: i,
    purpose: h,
    value: U,
    created: b ? new Date(b) : void 0,
    creator: pe(w),
    ...u
  };
}), Be = (e) => e.map((n) => {
  var o;
  const t = { ...n };
  return delete t.annotation, (o = t.id) != null && o.startsWith("temp-") && delete t.id, t;
}), he = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], ge = () => {
  const e = [...he];
  return { assignRandomColor: () => {
    const o = Math.floor(Math.random() * e.length), i = e[o];
    return e.splice(o, 1), i;
  }, releaseColor: (o) => e.push(o) };
}, me = () => {
  const e = ge();
  return { addUser: (o, i) => {
    const h = e.assignRandomColor();
    return {
      label: i.name || i.id,
      avatar: i.avatar,
      color: h
    };
  }, removeUser: (o) => e.releaseColor(o.appearance.color) };
}, Ae = (e, n) => e.every((t) => e.includes(t)) && n.every((t) => e.includes(t)), Ie = ue(), ke = (e = me()) => {
  const n = P(), t = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = (s, f) => {
    if (t.has(s)) {
      console.warn("Attempt to add user that is already present", s, f);
      return;
    }
    const y = e.addUser(s, f);
    t.set(s, {
      ...f,
      presenceKey: s,
      appearance: y
    });
  }, h = (s) => {
    const f = t.get(s);
    if (!f) {
      console.warn("Attempt to remove user that is not present", s);
      return;
    }
    e.removeUser(f), t.delete(s);
  }, U = (s) => {
    const f = new Set(s.map((L) => L.presenceKey)), y = s.filter(({ presenceKey: L }) => !t.has(L)), A = Array.from(t.values()).filter((L) => !f.has(L.presenceKey));
    y.forEach(({ presenceKey: L, user: C }) => i(L, C)), A.forEach((L) => {
      const { presenceKey: C } = L;
      o.has(C) && n.emit("selectionChange", L, null), h(C);
    }), (y.length > 0 || A.length > 0) && n.emit("presence", u());
  }, b = (s, f) => {
    const y = t.get(s);
    if (!y) {
      console.warn("Activity notification from user that is not present");
      return;
    }
    const A = o.get(s);
    (!A || !Ae(A, f)) && (o.set(s, f), n.emit("selectionChange", y, f));
  }, w = (s, f) => {
    const y = t.get(s);
    if (!y) {
      console.warn("Selection change for user that is not present", s);
      return;
    }
    f ? o.set(s, f) : o.delete(s), n.emit("selectionChange", y, f);
  }, u = () => [...Array.from(t.values())];
  return {
    getPresentUsers: u,
    notifyActivity: b,
    on: (s, f) => n.on(s, f),
    syncUsers: U,
    updateSelection: w
  };
};
export {
  ne as Ignore,
  O as Origin,
  Ie as PRESENCE_KEY,
  q as PointerSelectAction,
  Re as createAnonymousGuest,
  De as createBaseAnnotator,
  we as createBody,
  me as createDefaultAppearenceProvider,
  be as createHoverState,
  Te as createLifecyleObserver,
  ke as createPresenceState,
  ve as createSelectionState,
  ye as createStore,
  Le as createUndoStack,
  Se as createViewportState,
  ge as defaultColorProvider,
  M as diffAnnotations,
  Ce as getContributors,
  se as mergeChanges,
  G as onPointerSelect,
  re as parseAll,
  xe as parseW3CBodies,
  pe as parseW3CUser,
  Oe as serializeAll,
  Be as serializeW3CBodies,
  oe as shouldNotify,
  Ue as toSvelteStore
};
//# sourceMappingURL=annotorious-core.es.js.map
