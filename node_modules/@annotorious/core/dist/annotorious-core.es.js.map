{"version":3,"file":"annotorious-core.es.js","sources":["../../../node_modules/dequal/lite/index.mjs","../../../node_modules/svelte/internal/index.mjs","../../../node_modules/svelte/store/index.mjs","../src/state/Hover.ts","../src/state/Selection.ts","../../../node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/uuid/dist/esm-browser/v4.js","../src/utils/annotationUtils.ts","../src/utils/diffAnnotations.ts","../src/state/StoreObserver.ts","../src/state/Store.ts","../src/state/SvelteStore.ts","../../../node_modules/nanoevents/index.js","../src/state/UndoStack.ts","../src/state/Viewport.ts","../src/lifecycle/Lifecycle.ts","../src/model/FormatAdapter.ts","../src/model/Annotator.ts","../../../node_modules/nanoid/index.browser.js","../src/model/User.ts","../src/model/W3CAnnotation.ts","../src/presence/ColorPalette.ts","../src/presence/AppearanceProvider.ts","../src/presence/PresenceState.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n    constructor(options) {\n        this.options = options;\n        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\n    }\n    observe(element, listener) {\n        this._listeners.set(element, listener);\n        this._getObserver().observe(element, this.options);\n        return () => {\n            this._listeners.delete(element);\n            this._observer.unobserve(element); // this line can probably be removed\n        };\n    }\n    _getObserver() {\n        var _a;\n        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {\n            var _a;\n            for (const entry of entries) {\n                ResizeObserverSingleton.entries.set(entry.target, entry);\n                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n            }\n        }));\n    }\n}\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value == null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_iframe_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_iframe_resize_listener, add_location, add_render_callback, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier} [start]\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=} start\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0 && stop) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let started = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (started) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        started = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n            // We need to set this to false because callbacks can still happen despite having unsubscribed:\n            // Callbacks might already be placed in the queue which doesn't know it should no longer\n            // invoke this derived store.\n            started = false;\n        };\n    });\n}\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @param store - store to make readonly\n */\nfunction readonly(store) {\n    return {\n        subscribe: store.subscribe.bind(store)\n    };\n}\n\nexport { derived, readable, readonly, writable };\n","import { writable } from 'svelte/store';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport type HoverState<T extends Annotation> = ReturnType<typeof createHoverState<T>>;\n\nexport const createHoverState = <T extends Annotation>(store: Store<T>) => {\n\n  const { subscribe, set } = writable<string>(null);\n\n  let currentHover: string = null;\n\n  subscribe(updated => currentHover = updated);\n\n  // Track store delete and update events\n  store.observe(( { changes }) => {    \n    if (currentHover) {\n      const isDeleted = changes.deleted.some(a => a.id === currentHover);\n      if (isDeleted)\n        set(null);\n    \n      const updated = changes.updated.find(({ oldValue }) => oldValue.id === currentHover);\n      if (updated)\n        set(updated.newValue.id);\n    }\n  });\n\n  return { \n    get current() { return currentHover },\n    subscribe, \n    set \n  };\n\n}\n","import { writable } from 'svelte/store';\nimport type {  Annotation } from '../model';\nimport type { Store } from './Store';\n   \nexport type Selection = {\n\n  selected: { id: string, editable?: boolean }[],\n\n  pointerEvent?: PointerEvent;\n\n}\n\nexport type SelectionState<T extends Annotation> = ReturnType<typeof createSelectionState<T>>;\n\nexport enum PointerSelectAction {\n\n  EDIT = 'EDIT', // Make annotation target(s) editable on pointer select\n  \n  SELECT = 'SELECT',  // Just select, but don't make editable\n\n  NONE = 'NONE' // Click won't select - annotation is completely inert\n\n}\n\nconst EMPTY: Selection = { selected: [] };\n\nexport const createSelectionState = <T extends Annotation>(\n  store: Store<T>,\n  selectAction: PointerSelectAction | ((a: Annotation) => PointerSelectAction) = PointerSelectAction.EDIT\n) => {\n  const { subscribe, set } = writable<Selection>(EMPTY);\n\n  let currentSelection: Selection = EMPTY;\n\n  subscribe(updated => currentSelection = updated);\n\n  const clear = () => set(EMPTY);\n\n  const isEmpty = () => currentSelection.selected?.length === 0;\n\n  const isSelected = (annotationOrId: T | string) => {\n    if (currentSelection.selected.length === 0)\n      return false;\n\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n    return currentSelection.selected.some(i => i.id === id);\n  }\n\n  // TODO enable CTRL select\n  const clickSelect = (id: string, pointerEvent: PointerEvent) => {\n    const annotation = store.getAnnotation(id);\n    if (annotation) {\n      const action = onPointerSelect(annotation, selectAction);\n      if (action === PointerSelectAction.EDIT)\n        set({ selected: [{ id, editable: true }], pointerEvent }); \n      else if (action === PointerSelectAction.SELECT)\n        set({ selected: [{ id }], pointerEvent }); \n      else\n        set({ selected: [], pointerEvent });\n    } else {\n      console.warn('Invalid selection: ' + id);\n    }\n  }\n\n  const setSelected = (idOrIds: string | string[], editable: boolean = true) => {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    // Remove invalid\n    const annotations = \n      ids.map(id => store.getAnnotation(id)).filter(a => a); \n\n    set({ selected: annotations.map(({ id }) => ({ id, editable })) });\n    \n    if (annotations.length !== ids.length)\n      console.warn('Invalid selection', idOrIds);\n  }\n\n  const removeFromSelection = (ids: string[]) => {\n    if (currentSelection.selected.length === 0)\n      return false;\n\n    const { selected } = currentSelection;\n\n    // Checks which of the given annotations are actually in the selection\n    const toRemove = selected.filter(({ id  }) => ids.includes(id))\n\n    if (toRemove.length > 0)\n      set({ selected: selected.filter(({ id }) => !ids.includes(id)) });\n  }\n\n  // Track store delete and update events\n  store.observe(({ changes }) =>\n    removeFromSelection(changes.deleted.map(a => a.id)));\n\n  return { \n    clear, \n    clickSelect, \n    get selected() { return currentSelection ? [...currentSelection.selected ] : null},\n    get pointerEvent() { return currentSelection ? currentSelection.pointerEvent : null },\n    isEmpty, \n    isSelected, \n    setSelected, \n    subscribe \n  };\n\n}\n\nexport const onPointerSelect = (\n  annotation: Annotation, \n  action?: PointerSelectAction | ((a: Annotation) => PointerSelectAction)\n): PointerSelectAction => (typeof action === 'function') ?\n    (action(annotation) || PointerSelectAction.EDIT) : \n    (action || PointerSelectAction.EDIT);\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation, AnnotationBody } from '../model/Annotation';\nimport type {  User } from '../model/User';\n/**\n * Returns all users listed as creators or updaters in any parts of this\n * annotation.\n */\nexport const getContributors = (annotation: Annotation): User[] => {\n  const { creator, updatedBy } = annotation.target;\n\n  const bodyCollaborators = annotation.bodies.reduce((users, body) =>  (\n    [...users, body.creator, body.updatedBy]\n  ), [] as User[]);\n\n  return [\n    creator,\n    updatedBy,\n    ...bodyCollaborators\n  ].filter(u => u); // Remove undefined\n}\n\nexport const createBody = (\n  annotation: Annotation, \n  payload: { [key: string]: any },\n  created?: Date,\n  creator?: User\n): AnnotationBody => ({\n  id: uuidv4(),\n  annotation: annotation.id,\n  created: created || new Date(),\n  creator,\n  ...payload\n});","import { dequal } from 'dequal/lite';\nimport type { Update } from '../state/StoreObserver';\nimport type { Annotation } from '../model/Annotation';\n\nconst getAddedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const oldBodyIds = new Set(oldValue.bodies.map(b => b.id));\n  return newValue.bodies.filter(b => !oldBodyIds.has(b.id));\n}\n\nconst getRemovedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const newBodyIds = new Set(newValue.bodies.map(b => b.id));\n  return oldValue.bodies.filter(b => !newBodyIds.has(b.id));\n}\n\nconst getChangedBodies = (oldValue: Annotation, newValue: Annotation) => \n  newValue.bodies\n    .map(newBody => {\n      const oldBody = oldValue.bodies.find(b => b.id === newBody.id);\n      return { newBody, oldBody: oldBody && !dequal(oldBody, newBody) ? oldBody : undefined }\n    })\n    .filter(({ oldBody }) => oldBody);\n\nconst hasTargetChanged = (oldValue: Annotation, newValue: Annotation) => \n  !dequal(oldValue.target, newValue.target);\n\nexport const diffAnnotations = <T extends Annotation = Annotation>(oldValue: T, newValue: T): Update<T> => {\n  const bodiesCreated = getAddedBodies(oldValue, newValue);\n  const bodiesDeleted = getRemovedBodies(oldValue, newValue);\n  const bodiesUpdated = getChangedBodies(oldValue, newValue);\n\n  return {\n    oldValue, \n    newValue,\n    bodiesCreated: bodiesCreated.length > 0 ? bodiesCreated : undefined,\n    bodiesDeleted: bodiesDeleted.length > 0 ? bodiesDeleted : undefined,\n    bodiesUpdated: bodiesUpdated.length > 0 ? bodiesUpdated : undefined,\n    targetUpdated: hasTargetChanged(oldValue, newValue) ? { oldTarget: oldValue.target, newTarget: newValue.target } : undefined\n  }\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model/Annotation';\nimport { diffAnnotations } from '../utils';\n\n/** Interface for listening to changes in the annotation store **/\nexport interface StoreObserver<T extends Annotation> { \n\n  onChange: { (event: StoreChangeEvent<T>): void };\n\n  options: StoreObserveOptions;\n\n}\n\n/** A change event fired when the store state changes **/\nexport interface StoreChangeEvent<T extends Annotation> {\n\n  origin: Origin;\n\n  changes: ChangeSet<T>;\n\n  state: T[];\n\n}\n\nexport interface ChangeSet<T extends Annotation> {\n\n  created?: T[];\n\n  deleted?: T[];\n\n  updated?: Update<T>[];\n\n}\n\nexport interface Update<T extends Annotation> {\n\n  oldValue: T;\n\n  newValue: T;\n\n  bodiesCreated?: AnnotationBody[];\n\n  bodiesDeleted?: AnnotationBody[];\n\n  bodiesUpdated?: Array<{ oldBody: AnnotationBody, newBody: AnnotationBody }>;\n\n  targetUpdated?: { oldTarget: AnnotationTarget, newTarget: AnnotationTarget};\n\n}\n\n/** Options to control which events the observer wants to get notified about **/\nexport interface StoreObserveOptions {\n\n  // Observe changes on targets, bodies or both?\n  ignore?: Ignore;\n\n  // Observe changes on one more specific annotations\n  annotations?: string | string[];\n\n  // Observer changes only for a specific origin\n  origin?: Origin\n\n}\n\n/** Allows the observer to ignore certain event types **/\nexport enum Ignore { \n\n  // Don't notify this observer for changes that involve bodies only\n  BODY_ONLY = 'BODY_ONLY',\n\n  // Don't notify for changes on targets only\n  TARGET_ONLY = 'TARGET_ONLY'\n\n}\n\n/** Allows the observer to listen only for events that originated locally or from a remote source **/\nexport enum Origin { \n  \n  LOCAL = 'LOCAL', \n  \n  REMOTE = 'REMOTE' \n\n}\n\n/** Tests if this observer should be notified about this event **/\nexport const shouldNotify = <T extends Annotation>(observer: StoreObserver<T>, event: StoreChangeEvent<T>) => {\n  const { changes, origin } = event;\n\n  const isRelevantOrigin = \n    !observer.options.origin || observer.options.origin === origin;\n\n  if (!isRelevantOrigin)\n    return false;\n\n  if (observer.options.ignore) {\n    const { ignore } = observer.options;\n\n    // Shorthand\n    const has = (arg: any[]) => arg?.length > 0;\n\n    const hasAnnotationChanges =\n      has(changes.created) || has(changes.deleted);\n\n    if (!hasAnnotationChanges) {\n      const hasBodyChanges =\n        changes.updated?.some(u => has(u.bodiesCreated) || has(u.bodiesDeleted) || has(u.bodiesUpdated));\n    \n      const hasTargetChanges = \n        changes.updated?.some(u => u.targetUpdated);\n\n      if (ignore === Ignore.BODY_ONLY && hasBodyChanges && !hasTargetChanges)\n        return false;\n\n      if (ignore === Ignore.TARGET_ONLY && hasTargetChanges && !hasBodyChanges)\n        return false;\n    }\n  }\n\n  if (observer.options.annotations) {\n    // This observer has a filter set on specific annotations - check affected\n    const affectedAnnotations = new Set([\n      ...changes.created.map(a => a.id),\n      ...changes.deleted.map(a => a.id),\n      ...changes.updated.map(({ oldValue }) => oldValue.id)\n    ]);\n\n    const observed = Array.isArray(observer.options.annotations) ?\n      observer.options.annotations : [ observer.options.annotations ];\n\n    return Boolean(observed.find(id => affectedAnnotations.has(id)));\n  } else {\n    return true;\n  }\n\n}\n\nexport const mergeChanges = <T extends Annotation>(changes: ChangeSet<T>, toMerge: ChangeSet<T>) => {\n\n  const previouslyCreatedIds = new Set((changes.created || []).map(a => a.id));\n  const previouslyUpdatedIds = new Set((changes.updated || []).map(({ newValue })=> newValue.id));\n\n  const createdIds = new Set((toMerge.created || []).map(a => a.id));\n  const deletedIds = new Set((toMerge.deleted || []).map(a => a.id));\n  const updatedIds = new Set((toMerge.updated || []).map(({ oldValue }) => oldValue.id));\n\n  // Updates that will be merged into create or previous update events\n  const mergeableUpdates = new Set((toMerge.updated || [])\n    .filter(({ oldValue }) => previouslyCreatedIds.has(oldValue.id) || previouslyUpdatedIds.has(oldValue.id))\n    .map(({ oldValue }) => oldValue.id ));\n\n  // * created *\n  // - drop created that were then deleted\n  // - merge any updates on created\n  // - append newly created\n  const created = [\n    ...(changes.created || [])\n      .filter(a => !deletedIds.has(a.id))\n      .map(a => updatedIds.has(a.id) \n        ? toMerge.updated.find(({ oldValue }) => oldValue.id === a.id).newValue\n        : a),\n    ...(toMerge.created || [])\n  ];\n\n  // * deleted *\n  // - drop deleted that were later re-created (redo action!)\n  // - append newly deleted, but remove any that delete annotations \n  //   that were created in the same round\n  const deleted = [\n    ...(changes.deleted || [])\n      .filter(a => !createdIds.has(a.id)),\n    ...(toMerge.deleted || []) \n      .filter(a => !previouslyCreatedIds.has(a.id))\n  ] \n\n  // * updated *\n  // - drop updates on deleted annotations\n  // - merge any updates that override previous ones\n  // - append new updates, but remove any that were merged\n  const updated = [\n    ...(changes.updated || [])\n      .filter(({ newValue }) => !deletedIds.has(newValue.id))\n      .map(update => {\n        const { oldValue, newValue } = update;\n        if (updatedIds.has(newValue.id)) {\n          const updated = toMerge.updated.find(u => u.oldValue.id === newValue.id).newValue;\n          return diffAnnotations(oldValue, updated);\n        } else {\n          return update;\n        }\n      }),\n    ...(toMerge.updated || []).filter(({ oldValue }) => !mergeableUpdates.has(oldValue.id))\n  ]\n\n  return { created, deleted, updated };\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model';\nimport { diffAnnotations } from '../utils';\nimport { Origin, shouldNotify, type Update, type ChangeSet } from './StoreObserver';\nimport type { StoreObserver, StoreChangeEvent, StoreObserveOptions } from './StoreObserver';\n\n// Shorthand\ntype AnnotationBodyIdentifier = { id: string, annotation: string }; \n\nexport type Store<T extends Annotation> = ReturnType<typeof createStore<T>>;\n\nconst isAnnotation = <T extends Annotation>(arg: any): arg is T => arg.id !== undefined;\n\nexport const createStore = <T extends Annotation>() => {\n\n  const annotationIndex = new Map<string, T>();\n\n  const bodyIndex = new Map<string, string>();\n\n  const observers: StoreObserver<T>[] = [];\n\n  const observe = (onChange: { (event: StoreChangeEvent<T>): void }, options: StoreObserveOptions = {}) =>\n    observers.push({ onChange, options });\n\n  const unobserve = (onChange: { (event: StoreChangeEvent<T>): void }) => {\n    const idx = observers.findIndex(observer => observer.onChange == onChange);\n    if (idx > -1)\n      observers.splice(idx, 1);\n  }\n\n  const emit = (origin: Origin, changes: ChangeSet<T>) => {\n    const event: StoreChangeEvent<T> = {\n      origin,\n      changes: {\n        created: changes.created || [],\n        updated: changes.updated || [],\n        deleted: changes.deleted || []\n      },\n      state: [...annotationIndex.values()]\n    };\n\n    observers.forEach(observer => {\n      if (shouldNotify(observer, event))\n        observer.onChange(event);\n    });\n  }\n\n  const addAnnotation = (annotation: T, origin = Origin.LOCAL) => {\n    const existing = annotationIndex.get(annotation.id);\n\n    if (existing) {\n      throw Error(`Cannot add annotation ${annotation.id} - exists already`);\n    } else {\n      annotationIndex.set(annotation.id, annotation);\n\n      annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      emit(origin, { created: [annotation] });\n    }\n  }\n\n  const updateOneAnnotation = (arg1: string | T, arg2?: T | Origin) => {\n    const updated: T = typeof arg1 === 'string' ? arg2 as T : arg1;\n\n    const oldId: string = typeof arg1 === 'string' ? arg1 : arg1.id;\n    const oldValue = annotationIndex.get(oldId);\n\n    if (oldValue) {\n      const update: Update<T> = diffAnnotations(oldValue, updated);\n\n      if (oldId === updated.id) {\n        annotationIndex.set(oldId, updated);\n      } else {\n        annotationIndex.delete(oldId);\n        annotationIndex.set(updated.id, updated);\n      }\n\n      oldValue.bodies.forEach(b => bodyIndex.delete(b.id));\n      updated.bodies.forEach(b => bodyIndex.set(b.id, updated.id));\n\n      return update;\n    } else {\n      console.warn(`Cannot update annotation ${oldId} - does not exist`);\n    }\n  }\n  \n  const updateAnnotation = (arg1: string | T, arg2: T | Origin = Origin.LOCAL, arg3 = Origin.LOCAL) => {\n    const origin: Origin = isAnnotation(arg2) ? arg3 : arg2;\n\n    const update = updateOneAnnotation(arg1, arg2);\n    if (update)\n      emit(origin, { updated: [update] })\n  }\n\n  const bulkUpdateAnnotation = (annotations: T[], origin = Origin.LOCAL) => {\n    const updated = annotations.reduce((updated, annotation) => {\n      const u = updateOneAnnotation(annotation);\n      return u ? [...updated, u] : updated;\n    }, [] as Update<T>[]);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const addBody = (body: AnnotationBody, origin = Origin.LOCAL) => {\n    const oldValue = annotationIndex.get(body.annotation);\n    if (oldValue) {\n      const newValue = { \n        ...oldValue,\n        bodies: [ ...oldValue.bodies, body ]\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      bodyIndex.set(body.id, newValue.id);\n\n      const update: Update<T> = {\n        oldValue, newValue, bodiesCreated: [ body ]\n      };\n\n      emit(origin, { updated: [update] });\n    } else {\n      console.warn(`Attempt to add body to missing annotation: ${body.annotation}`);\n    }\n  }\n\n  const all = () => [...annotationIndex.values()];\n\n  const clear = (origin = Origin.LOCAL) => { \n    const all = [...annotationIndex.values()];\n\n    annotationIndex.clear();\n    bodyIndex.clear();\n\n    emit(origin, { deleted: all });\n  }\n\n  const bulkAddAnnotation = (annotations: T[], replace = true, origin = Origin.LOCAL) => {\n    if (replace) {\n      // Delete existing first\n      const deleted = [...annotationIndex.values()];\n      annotationIndex.clear();\n      bodyIndex.clear();\n\n      annotations.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: annotations, deleted });\n    } else {\n      // Don't allow overwriting of existing annotations\n      const existing = annotations.reduce((all, next) => {\n        const existing = annotationIndex.get(next.id);\n        return existing ? [...all, existing ] : all;\n      }, []);\n\n      if (existing.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${existing.map(a => a.id).join(', ')}`);\n\n      annotations.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: annotations });\n    }\n  }\n\n  const deleteOneAnnotation = (annotationOrId: T | string) => {\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n\n    const existing = annotationIndex.get(id);\n    if (existing) {\n      annotationIndex.delete(id);\n      existing.bodies.forEach(b => bodyIndex.delete(b.id));\n      return existing;\n    } else {\n      console.warn(`Attempt to delete missing annotation: ${id}`);\n    }\n  }\n\n  const deleteAnnotation = (annotationOrId: T | string, origin = Origin.LOCAL) => {\n    const deleted = deleteOneAnnotation(annotationOrId);\n    if (deleted)\n      emit(origin, { deleted: [ deleted  ]});\n  }\n\n  const bulkDeleteAnnotation = (annotationsOrIds: (T | string)[], origin = Origin.LOCAL) => {\n    const deleted = annotationsOrIds.reduce((deleted, arg) => {\n      const existing = deleteOneAnnotation(arg);\n      return existing ? [...deleted, existing] : deleted;\n    }, [] as T[]);\n\n    if (deleted.length > 0)\n      emit(origin, { deleted });\n  }\n \n  const deleteBody = (body: AnnotationBodyIdentifier, origin = Origin.LOCAL) => {\n    const oldAnnotation = annotationIndex.get(body.annotation);\n\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === body.id);\n\n      if (oldBody) {\n        bodyIndex.delete(oldBody.id);\n\n        const newAnnotation = {\n          ...oldAnnotation,\n          bodies: oldAnnotation.bodies.filter(b => b.id !== body.id)\n        };\n\n        annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n        const update: Update<T> = {\n          oldValue: oldAnnotation, newValue: newAnnotation, bodiesDeleted: [oldBody]\n        };\n\n        emit(origin, { updated: [update] });\n      } else {\n        console.warn(`Attempt to delete missing body ${body.id} from annotation ${body.annotation}`);\n      }\n    } else {\n      console.warn(`Attempt to delete body from missing annotation ${body.annotation}`);\n    }\n  }\n\n  const getAnnotation = (id: string): T | undefined => {\n    const a = annotationIndex.get(id);\n    return a ? {...a} : undefined;\n  }\n\n  const getBody = (id: string): AnnotationBody | undefined => {\n    const annotationId = bodyIndex.get(id);\n    if (annotationId) {\n      const annotation = getAnnotation(annotationId);\n      const body = annotation.bodies.find(b => b.id === id);\n      if (body) {\n        return body;\n      } else {\n        console.error(`Store integrity error: body ${id} in index, but not in annotation`);\n      }\n    } else {\n      console.warn(`Attempt to retrieve missing body: ${id}`);\n    }\n  }\n\n  const updateOneBody = (oldBodyId: AnnotationBodyIdentifier, newBody: AnnotationBody) => {\n    if (oldBodyId.annotation !== newBody.annotation)\n      throw 'Annotation integrity violation: annotation ID must be the same when updating bodies';\n\n    const oldAnnotation = annotationIndex.get(oldBodyId.annotation);\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === oldBodyId.id);\n\n      const newAnnotation = { \n        ...oldAnnotation,\n        bodies: oldAnnotation.bodies.map(b => b.id === oldBody.id ? newBody : b)\n      };\n\n      annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n      if (oldBody.id !== newBody.id) {\n        bodyIndex.delete(oldBody.id);\n        bodyIndex.set(newBody.id, newAnnotation.id);\n      }\n\n      return {\n        oldValue: oldAnnotation, \n        newValue: newAnnotation,\n        bodiesUpdated: [{ oldBody, newBody }]\n      }\n    } else {\n      console.warn(`Attempt to add body to missing annotation ${oldBodyId.annotation}`);\n    }\n  }\n\n  const updateBody = (oldBodyId: AnnotationBodyIdentifier, newBody: AnnotationBody, origin = Origin.LOCAL) => {\n    const update = updateOneBody(oldBodyId, newBody);\n    emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateBodies = (bodies: AnnotationBody[], origin = Origin.LOCAL) => {\n    const updated = bodies.map(b => updateOneBody({ id: b.id, annotation: b.annotation }, b));\n    emit(origin, { updated });\n  }\n\n  const updateOneTarget = (target: AnnotationTarget): Update<T> => {\n    const oldValue = annotationIndex.get(target.annotation);\n    \n    if (oldValue) {\n      const newValue = { \n        ...oldValue, \n        target: {\n          ...oldValue.target,\n          ...target \n        }\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      return {\n        oldValue, newValue, targetUpdated: { \n          oldTarget: oldValue.target,\n          newTarget: target\n        }\n      };\n    } else {\n      console.warn(`Attempt to update target on missing annotation: ${target.annotation}`);\n    }\n  }\n\n  const updateTarget = (target: AnnotationTarget, origin = Origin.LOCAL) => {\n    const update = updateOneTarget(target);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateTargets = (targets: AnnotationTarget[], origin = Origin.LOCAL) => {\n    const updated = targets.map(updateOneTarget).filter(val => val);\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n\treturn {\n    addAnnotation,\n    addBody,\n    all,\n    bulkAddAnnotation,\n    bulkDeleteAnnotation,\n    bulkUpdateAnnotation,\n    bulkUpdateBodies,\n    bulkUpdateTargets,\n    clear,\n    deleteAnnotation,\n    deleteBody,\n    getAnnotation,\n    getBody,\n    observe,\n    unobserve,\n    updateAnnotation,\n    updateBody,\n    updateTarget\n\t};\n\n}","import type { Annotation, Annotator, AnnotatorState } from '../model';\nimport type { Store } from './Store';\nimport type { StoreChangeEvent } from './StoreObserver';\n\ntype Subscriber<T extends Annotation> = (annotation: T[]) => void; \n\nexport interface SvelteStore<T extends Annotation> extends Store<T> {\n\n  subscribe(onChange: Subscriber<T>): void;\n\n}\n\nexport interface SvelteAnnotatorState<T extends Annotation> extends AnnotatorState<T> {\n\n  store: SvelteStore<T>\n\n}\n\nexport interface SvelteAnnotator<T extends Annotation> extends Annotator<T> {\n\n  state: SvelteAnnotatorState<T>\n\n}\n\n/** \n * A simple wrapper around the event-based store implementation\n * that adds a Svelte shim, for use with the reactive '$' notation.\n * Other frameworks might not actually need this. But it's pretty\n * convenient for everyone using Svelte, as well as for the\n * basic (Svelte-based) Annotorious standard implementation.\n */\nexport const toSvelteStore = <T extends Annotation>(store: Store<T>): SvelteStore<T> => {\n\n  const subscribe = (onChange: Subscriber<T>) => {\n\n    // Register a store observer on behalf of the subscriber\n    const shim = (event: StoreChangeEvent<T>) => onChange(event.state);\n    store.observe(shim);\n\n    // Immediately call the subscriber function with the\n    // current store value, according to the Svelte contract.\n    // https://stackoverflow.com/questions/68220955/how-does-svelte-unsubscribe-actually-work\n    onChange(store.all());\n\n    // Return the unsubscribe function\n    return () => store.unobserve(shim);\n  }\n\n  return {\n    ...store,\n    subscribe\n  }\n\n}","export let createNanoEvents = () => ({\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n","import { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\nimport { Origin } from './StoreObserver';\nimport { mergeChanges, type ChangeSet, type StoreChangeEvent, type Update } from './StoreObserver';\n\n// Duration with fast successive changes get merged \n// with the last event in the stack, rather than getting stacked\n// as a new undo/redo step.\nconst DEBOUNCE = 250;\n\nexport interface UndoStack <T extends Annotation> {\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  destroy(): void;\n\n  on<E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]): Unsubscribe;\n\n  undo(): void;\n\n  redo(): void;\n\n}\n\nexport interface UndoStackEvents <T extends Annotation> {\n\n  redo(change: ChangeSet<T>): void;\n\n  undo(change: ChangeSet<T>): void;\n\n}\n\nexport const createUndoStack = <T extends Annotation>(store: Store<T>): UndoStack<T> => {\n\n  const emitter = createNanoEvents<UndoStackEvents<T>>();\n\n  const changeStack: ChangeSet<T>[] = [];\n\n  let pointer = -1;\n\n  let muteEvents = false;\n\n  let lastEvent = 0;\n\n  const onChange = (event: StoreChangeEvent<T>) => {\n    if (!muteEvents) {\n      const { changes } = event;\n\n      const now = performance.now();\n\n      if (now - lastEvent > DEBOUNCE) {\n        // Put this change on the stack...\n        changeStack.splice(pointer + 1);\n        changeStack.push(changes);\n\n        // ...and update the pointer\n        pointer = changeStack.length - 1;\n      } else {\n        // Merge this change with the last in the stack\n        const last = changeStack.length - 1;\n        changeStack[last] = mergeChanges(changeStack[last], changes);\n      }\n\n      lastEvent = now;\n    }\n\n    muteEvents = false;\n  }\n\n  store.observe(onChange, { origin: Origin.LOCAL });\n\n  const undoCreated = (created: T[]) => \n    created?.length > 0 && store.bulkDeleteAnnotation(created);\n\n  const redoCreated = (created: T[]) =>\n    created?.length > 0 && store.bulkAddAnnotation(created, false);\n\n  const undoUpdated = (updated: Update<T>[]) =>\n    updated?.length > 0 && store.bulkUpdateAnnotation(updated.map(({ oldValue }) => oldValue));\n      \n  const redoUpdated = (updated: Update<T>[]) =>\n    updated?.length > 0 && store.bulkUpdateAnnotation(updated.map(({ newValue }) => newValue));\n\n  const undoDeleted = (deleted: T[]) => \n    deleted?.length > 0 && store.bulkAddAnnotation(deleted, false);\n\n  const redoDeleted = (deleted: T[]) =>\n    deleted?.length > 0 && store.bulkDeleteAnnotation(deleted);\n\n  const undo = () => {\n    if (pointer > -1) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer];\n\n      undoCreated(created);\n      undoUpdated(updated);\n      undoDeleted(deleted);\n\n      emitter.emit('undo', changeStack[pointer]);\n\n      pointer -= 1;\n    }\n  }\n\n  const canUndo = () => pointer > -1;\n\n  const redo = () => {\n    if (changeStack.length - 1 > pointer) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer + 1];\n\n      redoCreated(created);\n      redoUpdated(updated);\n      redoDeleted(deleted);\n\n      emitter.emit('redo', changeStack[pointer + 1]);\n\n      pointer += 1;\n    }\n  }\n\n  const canRedo = () => changeStack.length - 1 > pointer;\n\n  const destroy = () => store.unobserve(onChange);\n\n  const on = <E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]) => \n    emitter.on(event, callback);\n\n  return {\n    canRedo,\n    canUndo,\n    destroy,\n    on,\n    redo,\n    undo\n  }\n\n}","import { writable } from 'svelte/store';\n\nexport type ViewportState = ReturnType<typeof createViewportState>;\n\nexport const createViewportState = () => {\n\n  const { subscribe, set } = writable<string[]>([]);\n\n  return { \n    subscribe, \n    set\n  };\n\n}\n","import { dequal } from 'dequal/lite';\nimport type { Annotation, AnnotatorState, FormatAdapter } from '../model';\nimport { Origin, type ChangeSet, type UndoStack } from '../state';\nimport type { ViewportState } from '../state';\nimport type { LifecycleEvents } from './LifecycleEvents';\n\nexport type Lifecycle<I extends Annotation, E extends unknown> = \n  ReturnType<typeof createLifecyleObserver<I, E>>;\n\nexport const createLifecyleObserver = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I>,\n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>,\n  autoSave?: boolean\n) => {\n  const { store, selection, hover, viewport } = state;\n\n  const observers: Map<keyof LifecycleEvents, Function[]> = new Map();\n\n  // The currently selected annotations, in the state when they were selected \n  let initialSelection: I[] = [];\n\n  let currentHover: string | undefined;\n\n  let idleTimeout: ReturnType<typeof setTimeout>;\n\n  const on = <T extends keyof LifecycleEvents>(event: T, callback: LifecycleEvents<E>[T]) => {\n    if (observers.has(event)) {\n      observers.get(event).push(callback);\n    } else {\n      observers.set(event, [callback]);\n    }\n  }\n\n  const off = <T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]) => {\n    const callbacks = observers.get(event);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx > 0)\n        callbacks.splice(callbacks.indexOf(callback), 1);\n    }\n  }\n\n  const emit = (event: keyof LifecycleEvents<E>, arg0: I | I[], arg1?: I | PointerEvent) => {\n    if (observers.has(event)) {\n      setTimeout(() => {\n        observers.get(event).forEach(callback => { \n          if (adapter) {\n            const serialized0 = Array.isArray(arg0) ? \n              arg0.map(a => adapter.serialize(a)) : adapter.serialize(arg0);\n            \n            const serialized1: E | PointerEvent | undefined =\n              arg1 ? arg1 instanceof PointerEvent ? arg1 : adapter.serialize(arg1) : undefined;\n\n            callback(serialized0 as E & E[], serialized1); \n          } else {\n            callback(arg0 as E & E[], arg1 as unknown as E);  \n          }\n        });\n      }, 1);\n    }\n  }\n\n  const onIdleUpdate = () => {\n    const { selected } = selection;\n\n    // User idle after activity - fire update events for selected\n    // annotations that changed\n    const updatedSelected = selected.map(({ id }) => store.getAnnotation(id));\n\n    updatedSelected.forEach(updated => {\n      const initial = initialSelection.find(a => a.id === updated.id);\n      if (!initial || !dequal(initial, updated)) {\n        emit('updateAnnotation', updated, initial);\n      }\n    });\n\n    initialSelection = initialSelection.map(initial => {\n      const updated = updatedSelected.find(({ id }) => id === initial.id);\n      return updated ? updated : initial\n    });\n  }\n\n  selection.subscribe(({ selected })=> {\n    if (initialSelection.length === 0 && selected.length === 0)\n      return;\n\n    if (initialSelection.length === 0 && selected.length > 0) {\n      // A new selection was made - store the editable annotation as initial state\n      initialSelection = selected.map(({ id }) => store.getAnnotation(id));\n    } else if (initialSelection.length > 0 && selected.length === 0) {\n      // Deselect!\n      initialSelection.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);  \n        \n        if (updatedState && !dequal(updatedState, initial)) {\n          emit('updateAnnotation', updatedState, initial);\n        }\n      });\n\n      initialSelection = [];\n    } else {\n      // Changed selection\n      const initialIds = new Set(initialSelection.map(a => a.id));\n      const selectedIds = new Set(selected.map(({ id }) => id));\n\n      // Fire update events for deselected annotations that have changed\n      const deselected = initialSelection.filter(a => !selectedIds.has(a.id));\n      deselected.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);\n\n        if (updatedState && !dequal(updatedState, initial))\n          emit('updateAnnotation', updatedState, initial);\n      });\n\n      initialSelection = [\n        // Remove annotations that were deselected\n        ...initialSelection.filter(a => selectedIds.has(a.id)),\n        // Add editable annotations that were selected\n        ...selected.filter(({ id }) => !initialIds.has(id))\n          .map(({ id }) => store.getAnnotation(id))\n      ];\n    }\n\n    emit('selectionChanged', initialSelection);\n  });\n\n  hover.subscribe(id => {\n    if (!currentHover && id) {\n      emit('mouseEnterAnnotation', store.getAnnotation(id));\n    } else if (currentHover && !id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover));\n    } else if (currentHover && id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover));\n      emit('mouseEnterAnnotation', store.getAnnotation(id));\n    }\n\n    currentHover = id;\n  });\n\n  viewport?.subscribe(ids => \n    emit('viewportIntersect', ids.map(store.getAnnotation)));\n\n  store.observe(event => {\n    // autoSave option triggers update events on idleness\n    if (autoSave) {\n      if (idleTimeout)\n        clearTimeout(idleTimeout);\n\n      idleTimeout = setTimeout(onIdleUpdate, 1000);\n    }\n\n    // Local CREATE and DELETE events are applied immediately\n    const { created, deleted } = event.changes;\n    created.forEach(a => emit('createAnnotation', a));\n    deleted.forEach(a => emit('deleteAnnotation', a));\n\n    // Updates are only applied immediately if they involve body changes\n    const updatesWithBody = event.changes.updated.filter(u => [\n      ...(u.bodiesCreated || []),\n      ...(u.bodiesDeleted || []),\n      ...(u.bodiesUpdated || [])\n    ].length > 0);\n\n    // Emit an update with the new annototation and the stored initial state\n    updatesWithBody.forEach(({ oldValue, newValue }) => {\n      const initial = initialSelection.find(a => a.id === oldValue.id) || oldValue;\n\n      // Record the update as the new last known state\n      initialSelection = initialSelection\n        .map(a => a.id === oldValue.id ? newValue : a);\n\n      emit('updateAnnotation', newValue, initial);\n    });\n  }, { origin: Origin.LOCAL });\n\n  // Track remote changes - these should update the initial state\n  store.observe(event => {\n    if (initialSelection) {\n      const selectedIds = new Set(initialSelection.map(a => a.id));\n\n      const relevantUpdates = event.changes.updated\n        .filter(({ newValue }) => selectedIds.has(newValue.id))\n        .map(({ newValue }) => newValue);\n\n      if (relevantUpdates.length > 0) {\n        initialSelection = initialSelection.map(selected => {\n          const updated = relevantUpdates.find(updated => updated.id === selected.id);\n          return updated ? updated : selected;\n        })\n      }\n    }\n  }, { origin: Origin.REMOTE });\n\n  const onUndoOrRedo = (undo: boolean) => (changes: ChangeSet<I>) => {\n    const { created, deleted, updated } = changes;\n    created.forEach(a => emit('createAnnotation', a));\n    deleted.forEach(a => emit('deleteAnnotation', a));\n\n    if (undo)\n      updated.forEach(t => emit('updateAnnotation', t.oldValue, t.newValue));\n    else\n      updated.forEach(t => emit('updateAnnotation', t.newValue, t.oldValue));\n  }\n\n  undoStack.on('undo', onUndoOrRedo(true));\n  undoStack.on('redo', onUndoOrRedo(false));\n\n  return { on, off, emit }\n\n}","import type { Annotation } from './Annotation';\n\nexport interface FormatAdapter<A extends Annotation, T extends unknown> {\n\n  parse(serialized: T): ParseResult<A>;\n\n  serialize(core: A): T;\n\n}\n\nexport interface ParseResult<A extends Annotation> {\n\n  parsed?: A;\n  \n  error?: Error;\n\n}\n\nexport const serializeAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (annotations: A[]) => annotations.map(a => adapter.serialize(a));\n\nexport const parseAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (serialized: T[]) => serialized.reduce((result, next) => {\n      const { parsed, error } = adapter.parse(next);\n\n      return error ? {\n        parsed: result.parsed,\n        failed: [...result.failed, next ]\n      } : {\n        parsed: [...result.parsed, parsed ],\n        failed: result.failed\n      }\n    }, { parsed: [], failed: [] });\n  ","import type { Annotation } from './Annotation';\nimport type { User } from './User';\nimport type { PresenceProvider } from '../presence/PresenceProvider';\nimport { Origin, type HoverState, type SelectionState, type Store, type UndoStack, type ViewportState } from '../state';\nimport type { LifecycleEvents } from '../lifecycle/LifecycleEvents';\nimport { parseAll, type FormatAdapter } from './FormatAdapter';\nimport type { DrawingStyle } from './DrawingStyle';\nimport type { Filter } from './Filter';\n\n/**\n * Base annotator interface.\n * I ... internal core data model \n * E ... external adapted representation\n */\nexport interface Annotator<I extends Annotation = Annotation, E extends unknown = Annotation> {\n\n  addAnnotation(annotation: E): void;\n\n  cancelSelected(): void;\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  clearAnnotations(): void;\n\n  destroy(): void;\n\n  getAnnotationById(id: string): E | undefined;\n\n  getAnnotations(): E[];\n\n  getSelected(): E[];\n\n  getUser(): User;\n\n  loadAnnotations(url: string): Promise<E[]>;\n\n  redo(): void;\n\n  removeAnnotation(arg: E | string): E;\n\n  setAnnotations(annotations: E[]): void;\n\n  setFilter(filter: Filter): void;\n\n  setPresenceProvider?(provider: PresenceProvider): void;\n\n  setSelected(arg?: string | string[]): void;\n\n  setStyle(arg: DrawingStyle | ((annotation: I) => DrawingStyle) | undefined): void;\n\n  setUser(user: User): void;\n\n  undo(): void;\n\n  updateAnnotation(annotation: E): E;\n  \n  on<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  off<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  state: AnnotatorState<I>;\n\n}\n\nexport interface AnnotatorState<A extends Annotation> {\n\n  store: Store<A>;\n\n  selection: SelectionState<A>;\n\n  hover: HoverState<A>;\n\n  viewport: ViewportState;\n\n}\n\nexport const createBaseAnnotator = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I>, \n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>\n) => {\n\n  const { store, selection } = state;\n\n  const addAnnotation = (annotation: E) => {\n    if (adapter) {\n      const { parsed, error } = adapter.parse(annotation);\n      if (parsed) {\n        store.addAnnotation(parsed, Origin.REMOTE);\n      } else {\n        console.error(error);\n      }\n    } else {\n      store.addAnnotation(annotation as unknown as I, Origin.REMOTE);\n    }\n  }\n\n  const cancelSelected = () => selection.clear();\n\n  const clearAnnotations = () => store.clear();\n\n  const getAnnotationById = (id: string): E | undefined => {\n    const annotation = store.getAnnotation(id);\n    return (adapter && annotation) ?\n      adapter.serialize(annotation) as E : annotation as unknown as E;\n  }\n\n  const getAnnotations = () =>\n    (adapter ? store.all().map(adapter.serialize) : store.all()) as E[];\n\n  const getSelected = () => {\n    const selectedIds = selection.selected?.map(s => s.id) || [];\n\n    const selected = selectedIds.map(id => store.getAnnotation(id));\n\n    return adapter \n      ? selected.map(adapter.serialize) \n      : selected as unknown as E[];\n  }\n\n  const loadAnnotations = (url: string) =>\n    fetch(url)\n      .then((response) => response.json())\n      .then((annotations) => {\n        setAnnotations(annotations);\n        return annotations;\n      });\n\n  const removeAnnotation = (arg: E | string): E => {\n    if (typeof arg === 'string') {\n      const annotation = store.getAnnotation(arg);\n      store.deleteAnnotation(arg);\n\n      return adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n    } else {\n      const annotation = adapter ? adapter.parse(arg).parsed : (arg as unknown as I);\n      store.deleteAnnotation(annotation);\n      return arg;\n    }\n  }\n\n  const setAnnotations = (annotations: E[]) => {\n    if (adapter) {\n      const { parsed, failed } = parseAll(adapter)(annotations);\n\n      if (failed.length > 0)\n        console.warn(`Discarded ${failed.length} invalid annotations`, failed);\n\n      store.bulkAddAnnotation(parsed, true, Origin.REMOTE);\n    } else {\n      store.bulkAddAnnotation(annotations as unknown as I[], true, Origin.REMOTE);\n    }\n  }\n\n  const setSelected = (arg?: string | string[]) => {\n    if (arg) {\n      selection.setSelected(arg);\n    } else {\n      selection.clear();\n    }\n  }\n\n  const updateAnnotation = (updated: E): E => {\n    if (adapter) {\n      const crosswalked = adapter.parse(updated).parsed;\n      const previous = adapter.serialize(store.getAnnotation(crosswalked.id));\n      store.updateAnnotation(crosswalked);\n      return previous;\n    } else {\n      const previous = store.getAnnotation((updated as unknown as I).id);\n      store.updateAnnotation(updated as unknown as I);\n      return previous as unknown as E;\n    }\n  }\n\n  // Note that we don't spread the undoStack - it has a .destroy()\n  // method that would likely get overwritten by other Annotator implementations\n  // if people are not careful.\n  return { \n    addAnnotation,\n    cancelSelected,\n    canRedo: undoStack.canRedo,\n    canUndo: undoStack.canUndo,\n    clearAnnotations,\n    getAnnotationById,\n    getAnnotations,\n    getSelected,\n    loadAnnotations,\n    redo: undoStack.redo,\n    removeAnnotation,\n    setAnnotations,\n    setSelected,\n    undo: undoStack.undo,\n    updateAnnotation\n  }\n\n}","export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n","import { customAlphabet } from 'nanoid';\n\nexport interface User {\n\n  id: string;\n\n  isGuest?: boolean;\n\n  name?: string;\n\n  avatar?: string;\n\n}\n\nexport const createAnonymousGuest = () => {\n  const nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', 20);\n  \n  return { isGuest: true, id: nanoid() }\n}","import type { AnnotationBody } from './Annotation';\n\nexport interface W3CAnnotation {\n\n  '@context': 'http://www.w3.org/ns/anno.jsonld';\n\n  type: 'Annotation';\n\n  id: string;\n\n  body: W3CAnnotationBody | W3CAnnotationBody[]\n\n  target: W3CAnnotationTarget | W3CAnnotationTarget[];\n\n  [key: string]: any;\n\n}\n\nexport interface W3CAnnotationBody {\n\n  id?: string;\n\n  type?: string;\n\n  purpose?: string;\n\n  value?: string;\n\n  source?: string;\n\n  created?: Date;\n\n  creator?: {\n\n    type?: string;\n\n    id: string;\n\n    name?: string;\n\n  };\n\n}\n\nexport interface W3CAnnotationTarget {\n\n  source: string;\n\n  selector?: W3CSelector | W3CSelector[];\n\n}\n\nexport interface W3CSelector {\n\n  type: string;\n\n  conformsTo?: string;\n\n  value: string;\n}\n\n// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\nconst hashCode = (obj: Object): string => {\n  const str = JSON.stringify(obj);\n\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n      let chr = str.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n  }\n\n  return `${hash}`;\n}\n\nexport const parseW3CUser = (user?: any) => user \n  ? typeof user === 'object' ? { ...user } : user : undefined;\n\n/**\n * Helper to crosswalk the W3C annotation body to a list of core AnnotationBody objects.\n */\nexport const parseW3CBodies = (\n  body: W3CAnnotationBody | W3CAnnotationBody[], \n  annotationId: string\n): AnnotationBody[] => (Array.isArray(body) ? body : [body]).map(body => {\n\n  // Exctract properties that conform to the internal model, but keep custom props\n  const { id, type, purpose, value, created, creator, ...rest } = body;\n\n  // The internal model strictly requires IDs. (Because multi-user scenarios\n  // will have problems without them.) In the W3C model, bodys *may* have IDs.\n  // We'll create ad-hoc IDs for bodies without IDs, but want to make sure that\n  // generating the ID is idempotent: the same body should always get the same ID.\n  // This will avoid unexpected results when checking for equality.  \n  return {\n    id: id || `temp-${hashCode(body)}`,\n    annotation: annotationId,\n    type,\n    purpose,\n    value,\n    created: created ? new Date(created) : undefined,\n    creator: parseW3CUser(creator), \n    ...rest\n  }\n\n});\n\n/** Serialization helper to remove core-specific fields from the annotation body **/\nexport const serializeW3CBodies = (bodies: AnnotationBody[]): W3CAnnotationBody[] => \n  bodies.map(b => {\n    const w3c = { ...b };\n    delete w3c.annotation;\n\n    if (w3c.id?.startsWith('temp-'))\n      delete w3c.id;\n  \n    return w3c;\n  });","// SEABORN_BRIGHT\nexport const DEFAULT_PALETTE: Palette = [\n  '#ff7c00', // orange\n  '#1ac938', // green\n  '#e8000b', // red\n  '#8b2be2', // purple\n  '#9f4800', // brown\n  '#f14cc1', // pink\n  '#ffc400', // khaki\n  '#00d7ff', // cyan\n  '#023eff'  // blue\n];\n\nexport type Palette = string[];","import type { User } from '../model/User';\nimport type { Appearance } from './Appearance';\nimport type { PresentUser } from './PresentUser';\nimport { DEFAULT_PALETTE } from './ColorPalette';\n\nexport interface AppearanceProvider {\n\n  addUser(presenceKey: string, user: User): Appearance;\n\n  removeUser(user: PresentUser): void;\n\n}\n\nexport const defaultColorProvider = () => {\n\n  const unassignedColors = [...DEFAULT_PALETTE];\n\n  const assignRandomColor = () => {\n    const rnd = Math.floor(Math.random() * unassignedColors.length);\n    const color = unassignedColors[rnd];\n\n    unassignedColors.splice(rnd, 1);\n\n    return color;\n  }\n\n  const releaseColor = (color: string) =>\n    unassignedColors.push(color);\n\n  return { assignRandomColor, releaseColor };\n\n}\n\nexport const createDefaultAppearenceProvider = () => {\n\n  const colorProvider = defaultColorProvider();\n\n  const addUser = (presenceKey: string, user: User): Appearance => {\n    const color = colorProvider.assignRandomColor();\n\n    return {\n      label: user.name || user.id,\n      avatar: user.avatar,\n      color\n    };\n  }\n\n  const removeUser = (user: PresentUser) =>\n    colorProvider.releaseColor(user.appearance.color);\n\n  return { addUser, removeUser }\n  \n}","import { nanoid } from 'nanoid';\nimport { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { User } from '../model/User';\nimport type { PresentUser } from './PresentUser';\nimport type { PresenceEvents } from './PresenceEvents';\nimport { createDefaultAppearenceProvider } from './AppearanceProvider';\nimport type { AppearanceProvider } from './AppearanceProvider';\n\nexport interface PresenceState {\n\n  // Get users currently present to this room\n  getPresentUsers(): PresentUser[];\n\n  // Notify of a given present user's activity on the given annotations\n  notifyActivity(presenceKey: string, annotationIds: string[]): void;\n\n  // Add a listener for the given presence event\n  on<E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]): Unsubscribe;\n\n  // Initial sync - which users are present under which keys\n  syncUsers(state: { presenceKey: string, user: User }[]): void;\n\n  // Update the selection state for the given prresent user\n  updateSelection(presenceKey: string, selection: string[] | null): void;\n\n}\n\nconst isListEqual = (listA: any[], listB: any[]) => \n  listA.every(a => listA.includes(a)) && listB.every(b => listA.includes(b));\n\n// This client's presence key\nexport const PRESENCE_KEY = nanoid();\n\nexport const createPresenceState = (\n  appearanceProvider: AppearanceProvider = createDefaultAppearenceProvider()\n): PresenceState => {\n\n  const emitter = createNanoEvents<PresenceEvents>();\n\n  const presentUsers = new Map<string, PresentUser>();\n\n  const selectionStates = new Map<string, string[]>();\n\n  const addUser = (presenceKey: string, user: User) => {\n    if (presentUsers.has(presenceKey)) {\n      console.warn('Attempt to add user that is already present', presenceKey, user);\n      return;    \n    }\n\n    const appearance = appearanceProvider.addUser(presenceKey, user);\n\n    presentUsers.set(presenceKey, { \n      ...user,\n      presenceKey,\n      appearance\n    });\n  }\n\n  const removeUser = (presenceKey: string) => {\n    const user = presentUsers.get(presenceKey);\n    if (!user) {\n      console.warn('Attempt to remove user that is not present', presenceKey);\n      return;\n    }\n\n    appearanceProvider.removeUser(user);\n\n    presentUsers.delete(presenceKey);\n  }\n\n  const syncUsers = (state: { presenceKey: string, user: User }[]) => {\n    // const keys = new Set(others.map(s => s.presenceKey));\n    const keys = new Set(state.map(s => s.presenceKey));\n\n    // These users need to be added to the presentUsers list\n    // const toAdd = others.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n    const toAdd = state.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n\n    // These users need to be dropped from the list\n    const toRemove = Array.from(presentUsers.values()).filter(presentUser =>\n      !keys.has(presentUser.presenceKey));\n\n    toAdd.forEach(({ presenceKey, user }) => addUser(presenceKey, user));\n\n    toRemove.forEach(user => {\n      const { presenceKey } = user;\n\n      // If this user has a selection, fire deselect event\n      if (selectionStates.has(presenceKey))\n        emitter.emit('selectionChange', user, null);\n\n      removeUser(presenceKey)\n    });\n\n    if (toAdd.length > 0 || toRemove.length > 0)\n      emitter.emit('presence', getPresentUsers());\n  }\n\n  const notifyActivity = (presenceKey: string, annotationIds: string[]) => {    \n    const user = presentUsers.get(presenceKey);\n    \n    if (!user) {\n      console.warn('Activity notification from user that is not present');\n      return;\n    }\n\n    const currentSelection = selectionStates.get(presenceKey);\n\n    // Was there a selection change we might have missed?\n    if (!currentSelection || !isListEqual(currentSelection, annotationIds)) {\n      selectionStates.set(presenceKey, annotationIds);\n      emitter.emit('selectionChange', user, annotationIds);\n    }\n  }\n\n  const updateSelection = (presenceKey: string, selection: string[] | null) => {\n    const from = presentUsers.get(presenceKey);\n    if (!from) {\n      console.warn('Selection change for user that is not present', presenceKey);\n      return;\n    }\n\n    if (selection)\n      selectionStates.set(presenceKey, selection);\n    else \n      selectionStates.delete(presenceKey);\n\n    emitter.emit('selectionChange', from, selection);\n  }\n\n  const getPresentUsers = () =>\n    [...Array.from(presentUsers.values())];\n    \n  const on = <E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]) =>\n    emitter.on(event, callback);\n\n  return {\n    getPresentUsers,\n    notifyActivity,\n    on,\n    syncUsers,\n    updateSelection\n  }\n\n}"],"names":["has","dequal","foo","bar","ctor","len","noop","safe_not_equal","a","b","subscriber_queue","writable","value","start","stop","subscribers","set","new_value","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","createHoverState","store","currentHover","updated","changes","oldValue","PointerSelectAction","EMPTY","createSelectionState","selectAction","currentSelection","clear","isEmpty","_a","isSelected","annotationOrId","id","clickSelect","pointerEvent","annotation","action","onPointerSelect","setSelected","idOrIds","editable","ids","annotations","removeFromSelection","selected","getRandomValues","rnds8","rng","byteToHex","unsafeStringify","arr","offset","randomUUID","native","v4","options","buf","rnds","getContributors","creator","updatedBy","bodyCollaborators","users","body","u","createBody","payload","created","uuidv4","getAddedBodies","newValue","oldBodyIds","getRemovedBodies","newBodyIds","getChangedBodies","newBody","oldBody","hasTargetChanged","diffAnnotations","bodiesCreated","bodiesDeleted","bodiesUpdated","Ignore","Origin","shouldNotify","observer","event","_b","origin","ignore","arg","hasBodyChanges","hasTargetChanges","affectedAnnotations","mergeChanges","toMerge","previouslyCreatedIds","previouslyUpdatedIds","createdIds","deletedIds","updatedIds","mergeableUpdates","deleted","isAnnotation","createStore","annotationIndex","bodyIndex","observers","observe","onChange","unobserve","idx","emit","addAnnotation","updateOneAnnotation","arg1","arg2","oldId","updateAnnotation","arg3","bulkUpdateAnnotation","addBody","all","bulkAddAnnotation","replace","existing","next","deleteOneAnnotation","deleteAnnotation","bulkDeleteAnnotation","annotationsOrIds","deleteBody","oldAnnotation","newAnnotation","getAnnotation","getBody","annotationId","updateOneBody","oldBodyId","updateBody","bulkUpdateBodies","bodies","updateOneTarget","target","targets","val","toSvelteStore","shim","createNanoEvents","args","callbacks","length","cb","DEBOUNCE","createUndoStack","emitter","changeStack","pointer","muteEvents","lastEvent","now","last","undoCreated","redoCreated","undoUpdated","redoUpdated","undoDeleted","redoDeleted","callback","createViewportState","createLifecyleObserver","state","undoStack","adapter","autoSave","selection","hover","viewport","initialSelection","idleTimeout","on","off","arg0","serialized0","serialized1","onIdleUpdate","updatedSelected","initial","updatedState","initialIds","selectedIds","relevantUpdates","onUndoOrRedo","undo","t","serializeAll","parseAll","serialized","result","parsed","error","createBaseAnnotator","cancelSelected","clearAnnotations","getAnnotationById","getAnnotations","getSelected","s","loadAnnotations","url","response","setAnnotations","removeAnnotation","failed","crosswalked","previous","random","bytes","customRandom","alphabet","defaultSize","getRandom","mask","step","size","j","customAlphabet","nanoid","byte","createAnonymousGuest","hashCode","obj","str","hash","chr","parseW3CUser","user","parseW3CBodies","type","purpose","rest","serializeW3CBodies","w3c","DEFAULT_PALETTE","defaultColorProvider","unassignedColors","rnd","color","createDefaultAppearenceProvider","colorProvider","presenceKey","isListEqual","listA","listB","PRESENCE_KEY","createPresenceState","appearanceProvider","presentUsers","selectionStates","addUser","appearance","removeUser","syncUsers","keys","toAdd","toRemove","presentUser","getPresentUsers","notifyActivity","annotationIds","updateSelection","from"],"mappings":"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","x_google_ignoreList":[0,1,2,5,6,7,8,14,20]}